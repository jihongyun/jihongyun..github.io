{"meta":{"title":"鸿运的博客","subtitle":"鸿运的小屋","description":"技术学习","author":"Bill","url":"http://yoursite.com"},"pages":[{"title":"404","date":"2018-11-05T12:48:23.000Z","updated":"2018-11-05T12:48:23.978Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-05T09:50:53.000Z","updated":"2018-11-05T09:51:28.978Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-11-05T05:22:26.000Z","updated":"2018-11-05T05:23:29.701Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"search","date":"2018-11-05T12:48:10.000Z","updated":"2018-11-05T12:48:10.833Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-05T05:18:17.000Z","updated":"2018-11-05T08:41:36.830Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-11-05T08:42:56.056Z","updated":"2018-11-05T08:42:56.056Z","comments":true,"path":"image/markdown.html","permalink":"http://yoursite.com/image/markdown.html","excerpt":"","text":""},{"title":"","date":"2018-11-05T01:36:07.114Z","updated":"2018-11-05T01:36:07.114Z","comments":true,"path":"image/MySQL的部署.html","permalink":"http://yoursite.com/image/MySQL的部署.html","excerpt":"","text":"阿里云服务系统：centOS7一、使用root登陆服务器为了避免不必要的踩坑，直接先更新一下系统。1执行命令：yum -y update 等待出现：123 grub2.x86_64 1:2.02-0.64.el7.centos grub2-tools.x86_64 1:2.02-0.64.el7.centosComplete! 二、重启服务器1执行命令：init 6 三、先检查一下自己是否装了MySQL数据库，如果已经装了将其删除，避免后续不必要的麻烦。1检查命令： rpm -qa | grep mysql 1卸载命令： yum –y remove mysql 四、下载MySQL安装包执行命令：（两个不同的版本自行选择）1rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 1rpm -ivh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm 等待下载 五、安装MySQL1执行命令：yum install -y mysql-server 等待出现Complete！ 六、开启服务执行命令：systemctl start mysqld.service 七、查看MySQL默认的密码1执行命令：grep &apos;temporary password&apos; /var/log/mysqld.log 第一次装，应该是没有的（我的是没有的）。 八、登录MySQL1.上一步没有获取到密码。1执行命令：mysql -uroot -p 如果输入密码直接回车。 2.上一步获取到密码。例如密码为：password1执行命令：mysql -uroot -ppassword 九、进入MySQL系统，修改掉当前用户的密码。例如：修改密码为”Abc123!_“。1执行命令：SET PASSWORD = PASSWORD(&apos;Abc123!_&apos;); 搞了这么多不就是想远程登录。激动人心的时候到了。 十、开启远程登录，授权root远程登录。1执行命令：GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;Abc123!_&apos; WITH GRANT OPTION; 为了将授权立即生效：1执行命令：flush privileges; 好了centOS7上面的MySQL已经部署好了，下一步我们就通过Navicat连接。"}],"posts":[{"title":"rabbitMQ理解","slug":"消息队列-rabbitMQ理解","date":"2018-11-23T09:44:37.042Z","updated":"2018-11-23T09:44:37.163Z","comments":true,"path":"2018/11/23/消息队列-rabbitMQ理解/","link":"","permalink":"http://yoursite.com/2018/11/23/消息队列-rabbitMQ理解/","excerpt":"","text":"消息案例发送请求工作队列-消息公平分发(fair dispatch)简单的消费队列项目中有几个角色：生产者、消费者、队列。真实开发中消费者存在多个。比如用户注册功能开发，用户注册成功，会相应用户发送邮件，同时发送手机短信。 send生产者com.jihongyun.fair;123456789101112131415161718192021222324252627282930313233343536373839404142434445import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * 消息发送方 * 发送消息到Mq 指定队列 */public class Sender &#123; public static final String QUEUE_NAME=&quot;work_fair&quot;; public static void main(String[] args) throws Exception&#123; ConnectionFactory factory=new ConnectionFactory(); /** * 主机ip * 客户端连接端口号 5672 * 设置操作的 virtual host * 设置用户名 * 设置密码 */ factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;test&quot;); factory.setUsername(&quot;jihongyun&quot;); factory.setPassword(&quot;jihongyun&quot;); // 获取连接对象 Connection connection= factory.newConnection(); // 获取通道对象 Channel channel=connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME,false,false,false,null); channel.basicQos(1); for(int i=0;i&lt;30;i++)&#123; // 声明消息内容 String msg=&quot;工作队列_轮询消息&quot;+i; // 发送消息到队列 channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,msg.getBytes(&quot;utf-8&quot;)); System.out.println(&quot;生产者产生消息--&gt;&quot;+msg); Thread.sleep(1000); &#125; // 关闭资源 channel.close(); connection.close(); &#125;&#125; 消费者11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.jihongyun.fair;import com.rabbitmq.client.*;import java.io.IOException;/** * 消息接收方 * 接收指定队列 消息内容 */public class Receiver01 &#123; public static final String QUEUE_NAME=&quot;work_fair&quot;; public static void main(String[] args) throws Exception&#123; ConnectionFactory factory=new ConnectionFactory(); /** * 主机ip * 客户端连接端口号 5672 * 设置操作的 virtual host * 设置用户名 * 设置密码 */ factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;test&quot;); factory.setUsername(&quot;jihongyun&quot;); factory.setPassword(&quot;jihongyun&quot;); Connection connection=factory.newConnection(); // 创建通道 Channel channel=connection.createChannel(); // 指定队列 channel.queueDeclare(QUEUE_NAME,false,false,false,null); channel.basicQos(1); Consumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String msg=new String(body,&quot;utf-8&quot;); System.out.println(&quot;消费方01_收到消息--&gt;&quot;+msg); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 手动回执 channel.basicAck(envelope.getDeliveryTag(),false); &#125; &#125;; // 自动回执 false 禁用自动回执 当消息处理完毕后再执行回执 channel.basicConsume(QUEUE_NAME,false,consumer); &#125;&#125; 消费者2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.jihongyun.fair;import com.rabbitmq.client.*;import java.io.IOException;/** * 消息接收方 * 接收指定队列 消息内容 */public class Receiver02 &#123; public static final String QUEUE_NAME=&quot;work_fair&quot;; public static void main(String[] args) throws Exception&#123; ConnectionFactory factory=new ConnectionFactory(); /** * 主机ip * 客户端连接端口号 5672 * 设置操作的 virtual host * 设置用户名 * 设置密码 */ factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;test&quot;); factory.setUsername(&quot;jihongyun&quot;); factory.setPassword(&quot;jihongyun&quot;); Connection connection=factory.newConnection(); // 创建通道 Channel channel=connection.createChannel(); // 指定队列 channel.queueDeclare(QUEUE_NAME,false,false,false,null); channel.basicQos(1); Consumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String msg=new String(body,&quot;utf-8&quot;); System.out.println(&quot;消费方02_收到消息--&gt;&quot;+msg); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 手动回执消息到Mq，防止当前消费者奔溃，导致消息丢失。 channel.basicAck(envelope.getDeliveryTag(),false); &#125; &#125;; //设置为true时，自动应答 channel.basicConsume(QUEUE_NAME,false,consumer); &#125;&#125; 最终的结果：从结果可以看出 1 号消费者消费消息数量明显高于 2 号，即消息通过 fair 机制被公平分发到每个消费者。工作队列-消息轮询分发(Round-robin)发送者（send）123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.jihongyun.rr;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * 消息发送方 * 发送消息到Mq 指定队列 */public class Sender &#123; public static final String QUEUE_NAME=&quot;work_rr&quot;; public static void main(String[] args) throws Exception&#123; ConnectionFactory factory=new ConnectionFactory(); /** * 主机ip * 客户端连接端口号 5672 * 设置操作的 virtual host * 设置用户名 * 设置密码 */ factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;test&quot;); factory.setUsername(&quot;jihongyun&quot;); factory.setPassword(&quot;jihongyun&quot;); // 获取连接对象 Connection connection= factory.newConnection(); // 获取通道对象 Channel channel=connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME,false,false,false,null); for(int i=0;i&lt;20;i++)&#123; // 声明消息内容 String msg=&quot;工作队列_轮询消息&quot;+i; // 发送消息到队列 channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,msg.getBytes(&quot;utf-8&quot;)); System.out.println(&quot;生产者产生消息--&gt;&quot;+msg); Thread.sleep(1000); &#125; // 关闭资源 channel.close(); connection.close(); &#125;&#125; 消费者1（receiver）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.jihongyun.rr;import com.rabbitmq.client.*;import java.io.IOException;/** * 消息接收方 * 接收指定队列 消息内容 */public class Receiver02 &#123; public static final String QUEUE_NAME=&quot;work_rr&quot;; public static void main(String[] args) throws Exception&#123; ConnectionFactory factory=new ConnectionFactory(); /** * 主机ip * 客户端连接端口号 5672 * 设置操作的 virtual host * 设置用户名 * 设置密码 */ factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;test&quot;); factory.setUsername(&quot;jihongyun&quot;); factory.setPassword(&quot;jihongyun&quot;); Connection connection=factory.newConnection(); // 创建通道 Channel channel=connection.createChannel(); // 指定队列 channel.queueDeclare(QUEUE_NAME,false,false,false,null); Consumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String msg=new String(body,&quot;utf-8&quot;); System.out.println(&quot;消费方02_收到消息--&gt;&quot;+msg); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; channel.basicConsume(QUEUE_NAME,true,consumer); &#125;&#125; 消费者212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.jihongyun.rr;import com.rabbitmq.client.*;import java.io.IOException;/** * 消息接收方 * 接收指定队列 消息内容 */public class Receiver01 &#123; public static final String QUEUE_NAME=&quot;work_rr&quot;; public static void main(String[] args) throws Exception&#123; ConnectionFactory factory=new ConnectionFactory(); /** * 主机ip * 客户端连接端口号 5672 * 设置操作的 virtual host * 设置用户名 * 设置密码 */ factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setVirtualHost(&quot;test&quot;); factory.setUsername(&quot;jihongyun&quot;); factory.setPassword(&quot;jihongyun&quot;); Connection connection=factory.newConnection(); // 创建通道 Channel channel=connection.createChannel(); // 指定队列 channel.queueDeclare(QUEUE_NAME,false,false,false,null); Consumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String msg=new String(body,&quot;utf-8&quot;); System.out.println(&quot;消费方01_收到消息--&gt;&quot;+msg); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; channel.basicConsume(QUEUE_NAME,true,consumer); &#125;&#125; 最终的结果：两个消费者轮流获取消息，直至最终，其实实际生产中，由于网络、处理速度等原因，并不会达到理想中的平均分配状态。","categories":[{"name":"消息队列(MQ-Message Queue)","slug":"消息队列-MQ-Message-Queue","permalink":"http://yoursite.com/categories/消息队列-MQ-Message-Queue/"}],"tags":[]},{"title":"java代码中操作rabbitMQ","slug":"消息队列-rabbitMQjava代码操作","date":"2018-11-23T03:48:02.894Z","updated":"2018-11-23T03:48:03.039Z","comments":true,"path":"2018/11/23/消息队列-rabbitMQjava代码操作/","link":"","permalink":"http://yoursite.com/2018/11/23/消息队列-rabbitMQjava代码操作/","excerpt":"","text":"导入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt; 提供者Send类12345678910111213141516171819202122232425262728293031323334package com.jihongyun;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * Created by xlf on 2018/11/23. */public class Sender &#123; private static String QUEUE_NAME = &quot;hello&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;localhost&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;test&quot;); connectionFactory.setUsername(&quot;jihongyun&quot;); connectionFactory.setPassword(&quot;jihongyun&quot;); //创建连接 Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //制定消息队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); //将消息推送至rabbitMq String msg = &quot;hello rebbitMq&quot;; channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,msg.getBytes(&quot;utf-8&quot;)); //关闭资源 channel.close(); connection.close(); &#125;&#125; receiver类代码12345678910111213141516171819202122232425262728293031323334package com.jihongyun;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * Created by xlf on 2018/11/23. */public class Receiver &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory connectionFactory = new ConnectionFactory(); connectionFactory.setHost(&quot;localhost&quot;); connectionFactory.setPort(5672); connectionFactory.setVirtualHost(&quot;test&quot;); connectionFactory.setUsername(&quot;jihongyun&quot;); connectionFactory.setPassword(&quot;jihongyun&quot;); Connection connection = connectionFactory.newConnection(); Channel channel = connection.createChannel(); //指定队列 channel.queueDeclare(&quot;hello&quot;, false, false, false, null); //DefaultConsumer类实现了Consumer接口，通过传入一个频道， // 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery Consumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP .BasicProperties properties, byte[] body) throws IOException &#123; String msg=new String(body,&quot;utf-8&quot;); System.out.println(&quot;消费方收到消息--&gt;&quot;+msg); &#125; &#125;; //自动回复队列应答 -- RabbitMQ中的消息确认机制 channel.basicConsume(&quot;hello&quot;, true, consumer); &#125;&#125;","categories":[],"tags":[]},{"title":"RabbitMq 安装与测试","slug":"消息队列--rabbitMq安装与测试","date":"2018-11-23T02:22:48.861Z","updated":"2018-11-23T02:22:49.330Z","comments":true,"path":"2018/11/23/消息队列--rabbitMq安装与测试/","link":"","permalink":"http://yoursite.com/2018/11/23/消息队列--rabbitMq安装与测试/","excerpt":"","text":"先下载Erlanghttp://www.erlang.org/downloads 安装Erlang(与普通软件安装一致)下载RabbitMqhttps://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.9/rabbitmq-server-3.7.9.exe 执行安装(默认盘 与普通软件安装一致)环境测试检查Mq 安装后以来的文件版本列表信息cd C:\\Program Files\\RabbitMQ Server\\rabbitmq_server-3.6.5/sbin 执行脚本命令rabbitmqctl.bat status 查看Mq 支持的插件列表rabbitmq-plugins.bat list 启用管理控制台插件rabbitmq-plugins.bat enable rabbitmq_management 浏览器访问 127.0.0.1:15672默认账号:用户名:guest 密码:guest 问题出现于解决:如果 执行rabbitmqctl.bat status 命令 没有出现对应列表结果 方式1:1. rabbitmqservice.bat install 2. rabbitmqservice.bat start 方式2(推荐):同步cookie 文件将 C:\\Windows\\.erlang.cookie copy 到C:\\Users\\lp","categories":[{"name":"消息队列(MQ-Message Queue)","slug":"消息队列-MQ-Message-Queue","permalink":"http://yoursite.com/categories/消息队列-MQ-Message-Queue/"}],"tags":[]},{"title":"redis小马金服中应用","slug":"数据库的应用-redis小马金服中的应用","date":"2018-11-21T08:42:31.630Z","updated":"2018-11-21T08:42:31.772Z","comments":true,"path":"2018/11/21/数据库的应用-redis小马金服中的应用/","link":"","permalink":"http://yoursite.com/2018/11/21/数据库的应用-redis小马金服中的应用/","excerpt":"","text":"使用redis的流程图 双重检查锁应用","categories":[{"name":"数据库应用","slug":"数据库应用","permalink":"http://yoursite.com/categories/数据库应用/"}],"tags":[]},{"title":"redis配置","slug":"redis配置-数据库配置","date":"2018-11-17T09:21:45.992Z","updated":"2018-11-17T09:21:46.087Z","comments":true,"path":"2018/11/17/redis配置-数据库配置/","link":"","permalink":"http://yoursite.com/2018/11/17/redis配置-数据库配置/","excerpt":"","text":"下载地址http://download.redis.io/releases/redis-4.0.9.tar.gz","categories":[{"name":"数据库配置","slug":"数据库配置","permalink":"http://yoursite.com/categories/数据库配置/"}],"tags":[]},{"title":"圆形插件","slug":"圆形插件-前端小插件","date":"2018-11-17T06:53:51.823Z","updated":"2018-11-17T06:53:51.944Z","comments":true,"path":"2018/11/17/圆形插件-前端小插件/","link":"","permalink":"http://yoursite.com/2018/11/17/圆形插件-前端小插件/","excerpt":"","text":"圆形框插件下载地址：https://github.com/s-yadav/radialIndicator.git配置定义HTML 渲染指示器DOM1&lt;div id=&quot;indicatorContainer&quot;&gt;&lt;/div&gt; 初始化加载圆形指示器1234567891011var progObj = radialIndicator(&apos;#indicatorContainer&apos; , &#123;radius:50, //定义圆形指示器的内部的圆的半径。barBgColor:&quot;#CCC&quot;, //定义圆形指示器的刻度条的背景颜色。barColor:&quot;#99CC33&quot;, //指示器数值样式percentage:true, //设置为true显示圆形指示器的百分比数值。// initValue:$(&quot;#indicatorVue&quot;).val(), //圆形指示器初始化的值。minValue:0, //圆形指示器的最小值。maxValue:100&#125;);progObj.animate($(&quot;#indicatorVue&quot;).val()); //启动动画","categories":[{"name":"前端小插件","slug":"前端小插件","permalink":"http://yoursite.com/categories/前端小插件/"}],"tags":[]},{"title":"","slug":"mybatis分页配置","date":"2018-11-16T12:11:08.935Z","updated":"2018-11-16T12:11:09.157Z","comments":true,"path":"2018/11/16/mybatis分页配置/","link":"","permalink":"http://yoursite.com/2018/11/16/mybatis分页配置/","excerpt":"","text":"利用mybatis分页插件配置引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt; mybatis.xml配置12345&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot; /&gt; &lt;/plugin&gt;&lt;/plugins&gt; java代码实现service层123Page&lt;Map&lt;String, Object&gt;&gt; page = PageHelper.startPage(PageNum,PageSize);page = basItemMapper.queryItemsByParams(basItemQuery);return new PageInfo&lt;Map&lt;String, Object&gt;&gt;(page); dao","categories":[],"tags":[]},{"title":"同步一步，arraylist和linkedlist的区别","slug":"面试题-","date":"2018-11-13T12:30:23.848Z","updated":"2018-11-13T12:30:24.105Z","comments":true,"path":"2018/11/13/面试题-/","link":"","permalink":"http://yoursite.com/2018/11/13/面试题-/","excerpt":"","text":"List中arrayList和linkedlist的区别。arraylist是基于动态数组的。查找效率高。但删除增加比较麻烦。linkedlist是基于链表的。查找效率低，每次都需要移动指针指向。 同步和异步同步：当我们向服务器发送一个请求，服务器没有返回结果给客服端之前，我们一直处于等待状态。异步：发送一个请求，不需要等待请求，继续进行（当前线程重新开了一个线程）。原因：http是应用层协议，一般是http同步请求。如果网络环境差，会阻塞。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[]},{"title":"迭代器","slug":"设计模式-迭代器","date":"2018-11-09T11:22:59.487Z","updated":"2018-11-09T11:22:59.600Z","comments":true,"path":"2018/11/09/设计模式-迭代器/","link":"","permalink":"http://yoursite.com/2018/11/09/设计模式-迭代器/","excerpt":"","text":"迭代器数据迭代，方便元素输出 应用场景集合：list set迭代器与for循环有啥区别？ 迭代器的优点demo演示","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[]},{"title":"web面试题","slug":"面试题-web面试题","date":"2018-11-09T06:47:16.847Z","updated":"2018-11-09T06:47:17.297Z","comments":true,"path":"2018/11/09/面试题-web面试题/","link":"","permalink":"http://yoursite.com/2018/11/09/面试题-web面试题/","excerpt":"","text":"web会话跟踪技术 为什么出现回话跟踪协议。 http ————》应用层协议 无状态 session–》浏览器到服务器的一次会话（无交互默认30分钟） session：服务端技术 第一次请求到达服务端，server生成惟一的session（内部产生），将sessionId随着相应携带到客户端，借助cookie存储sessionId到浏览器（写入到浏览器内存），后续请求进入server。 session和cookie session信息 存放用户敏感信息 server cookie client 数据量较小 敏感度较低数据 谈谈你理解的ORM 概念：对象关系映射。 关系库：非面向对象数据库。 java是面向对象。其中有矛盾，所以提出ORM思想。 ORM思想：每一个类都会对应一张表，属性对应字段，实例对象对应记录。 数据库框架：mybatis半自动化的ORM框架（表需要手动创建，sql需要自己写） hibernate：完全自动化ORM框架，操作对象就相当于操作表结构。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[]},{"title":"maven项目没有添加编译插件","slug":"maven项目没有添加编译插件","date":"2018-11-08T11:11:14.018Z","updated":"2018-11-08T11:11:14.136Z","comments":true,"path":"2018/11/08/maven项目没有添加编译插件/","link":"","permalink":"http://yoursite.com/2018/11/08/maven项目没有添加编译插件/","excerpt":"","text":"错误信息：12[ERROR] /F:/Object/ssm_dubbo_par/ssm_dubbo_api/src/main/java/com/jihongyun/api/base/BaseController.java:[3,81] 程序包com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations不存在[ERROR] /F:/Object/ssm_dubbo_par/ssm_dubbo_api/src/main/java/com/jihongyun/api/base/BaseController.java:[4,45] 程序包com.sun.xml.internal.ws.api.streaming不存在 解决方案：123456789101112131415&lt;plugins&gt; &lt;!-- 指定编译的虚拟机 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;utf8&lt;/encoding&gt; &lt;compilerArguments&gt; &lt;bootclasspath&gt;$&#123;java.home&#125;/lib/rt.jar&lt;/bootclasspath&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;","categories":[{"name":"IDear报错处理","slug":"IDear报错处理","permalink":"http://yoursite.com/categories/IDear报错处理/"}],"tags":[]},{"title":"spring面试题","slug":"面试题","date":"2018-11-07T01:52:00.141Z","updated":"2018-11-08T07:37:34.452Z","comments":true,"path":"2018/11/07/面试题/","link":"","permalink":"http://yoursite.com/2018/11/07/面试题/","excerpt":"","text":"ioc是什么？ioc:spring框架核心技术，控制反转与依赖注入。控制反转：应用程序创建对象过程转交给外部容器ioc来负责创建。可以使用xml配置。举例：对象的获取操作。原始是需要new一个对象。ioc：通过xml配置bean标签，或者注解+扫描器（controller，service，respository,component）依赖注入（也叫装配）：给对象属性赋值。举例：传统方式：获取UserService类需要new UserService（）；依赖注入：1.扫描+标签。（resource或aotuwired）2.通过set或构造器注入。ioc实现设计的相关技术：工厂模式、单例模式、反射、xml解析。ioc的优点：耦合度降低，代码入侵性低邮件服务定时任务信息服务 aop实现方式与应用场景实现方式：1.静态代理。2.动态代理：1.jdk 2.cglib控制场景：aop实现资源的权限控制，用户行为日志收集，系统操作收集，非法资源控制。优点：1.降低模块与模块之间的耦合度，提高业务代码的耦合度。2.提高代码的复用性。3.提高系统的扩展性。 springMVC的理解和执行过程理解：执行过程：1、用户发送请求。2、用户的请求发送到前端控制器。3、进入映射处理器，根据url匹配我们的处理器。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[]},{"title":"RPC基本概念","slug":"Apache Dubbo-RPC基本概念","date":"2018-11-06T14:53:33.288Z","updated":"2018-11-06T14:53:33.511Z","comments":true,"path":"2018/11/06/Apache Dubbo-RPC基本概念/","link":"","permalink":"http://yoursite.com/2018/11/06/Apache Dubbo-RPC基本概念/","excerpt":"","text":"RPC协议远程过程调用协议，属于一种规范，RPC跨越了传输层和应用层。采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器优点：使开发包括网络分布式程序在内的应用程序更加容易。 RPC框架进程间通信（IPC）：是在多任务操作系统或联网的计算机之间运行的程序和进程所用的通信技术。有两种类型的进程间通信（IPC）。本地过程调用（LPC）：LPC用在多任务操作系统中，使得同时运行的任务能互相会话。这些任务共享内存空间使任务同步和互相发送信息。远程过程调用（RPC）：Unix的生态系统中 RPC 可以在同一台电脑上不同进程进行，也可以在不同电脑上进行。PRC实现了不同。综上：RPC 或 LPC是上层建筑，IPC 是底层基础。RPC 框架有很多：比如 Thrift、dubbo、grpc 等。 RPC 与 HTTP、TCP、UDP、Socket 的区别 TCP/UDP: 都是传输协议，主要区别是 tcp 协议连接需要 3 次握手，断开需要四次挥手，是通过流来传输的，就是确定连接后，一直发送信息，传完后断开。udp 不需要进行连接，直接把信息封装成多个报文，直接发送。所以 udp 的速度更快写，但是不保证数据的完整性。 Http：超文本传输协议是一种应用层协议，建立在 TCP 协议之上 Socket：是在应用程序层面上对 TCP/IP 协议的封装和应用。 RPC 是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。所以 RPC 的实现可以通过不同的协议去实现比如可以使 http、RMI 等。 RPC 的运行流程","categories":[{"name":"Apache Dubbo","slug":"Apache-Dubbo","permalink":"http://yoursite.com/categories/Apache-Dubbo/"}],"tags":[]},{"title":"Apache Dubbo","slug":"Dubbo","date":"2018-11-06T01:40:13.178Z","updated":"2018-11-06T14:53:43.741Z","comments":true,"path":"2018/11/06/Dubbo/","link":"","permalink":"http://yoursite.com/2018/11/06/Dubbo/","excerpt":"","text":"Dubbo是一款高性能的javaRPC框架，它提供三大核心能力：面向接口的远程调用方法，智能容错和负载均衡，以及服务自动注册和发现。 Dubbo流程图 0-start 初始化在IOC容器启动时，对服务实现类实例化。 1-register 服务注册操作将服务的提供方信息写入到注册中心。 2-subscribe订阅服务消费者启动时，订阅注册信息的服务列表信息。 3-notify消息的通知服务变更时，注册中心推送变更消息到消费者。 4-invoke 远程的调用更具订阅的信息发起远程调用（同步操作会有阻塞情况的发生。） 5-conut 监控中心监控程序快速搭建一个简单的dubbo环境创建maven项目项目结构如图： 在dubbo_par中引入dubbo坐标12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.6&lt;/version&gt;&lt;/dependency&gt; dubbo_api中编写po类和接口User消费者对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.jihongyun.po;import java.io.Serializable;/** * Created by xlf on 2018/11/6. */public class User implements Serializable &#123; private static final long serialVersionUID = -1624346152087608103L; private Integer id; private String userName; private String userPwd; public User() &#123; &#125; public User(Integer id, String userName, String userPwd) &#123; this.id = id; this.userName = userName; this.userPwd = userPwd; &#125; public static long getSerialVersionUID() &#123; return serialVersionUID; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUserPwd() &#123; return userPwd; &#125; public void setUserPwd(String userPwd) &#123; this.userPwd = userPwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, userName=&apos;&quot; + userName + &apos;\\&apos;&apos; + &quot;, userPwd=&apos;&quot; + userPwd + &apos;\\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 定义接口及方法12345678910package com.jihongyun.service;import com.jihongyun.po.User;/** * Created by xlf on 2018/11/6. */public interface IUserService &#123; public User queryUserById(Integer userId);&#125; dubbo_provider服务端的构建加入坐标继承dubbo_api12345&lt;dependency&gt; &lt;groupId&gt;com.jihongyun&lt;/groupId&gt; &lt;artifactId&gt;dubbo_api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 创建实现接口IUserService的UserServiceImpl类123456789101112131415161718192021222324252627package com.jihongyun.provider;import com.jihongyun.po.User;import com.jihongyun.service.IUserService;import org.springframework.stereotype.Repository;import org.springframework.stereotype.Service;import java.util.HashMap;import java.util.Map;/** * Created by xlf on 2018/11/6. */@Servicepublic class UserServiceImpl implements IUserService &#123; //没有连接数据库所有直接写入user用户 private Map&lt;Integer, User&gt; users = new HashMap&lt;&gt;(); public UserServiceImpl() &#123; users.put(1,new User(1,&quot;bill&quot;,&quot;123456&quot;)); &#125; @Override public User queryUserById(Integer userId) &#123; return users.get(userId); &#125;&#125; provider.xml配置(spring.xml)1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.jihongyun.provider&quot;/&gt; &lt;!--dubbo环境的配置--&gt; &lt;!--应用名称--&gt; &lt;dubbo:application name=&quot;dubbo_provider&quot;/&gt; &lt;!--注册中心配置--&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;/&gt; &lt;!--指定公布的服务使用的协议和端口号--&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt; &lt;!--配置公布的服务--&gt; &lt;dubbo:service interface=&quot;com.jihongyun.service.IUserService&quot; ref=&quot;userServiceImpl&quot;/&gt;&lt;/beans&gt; 服务器发布1234567891011121314151617package com.jihongyun;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;/** * Created by xlf on 2018/11/6. */public class Publisher &#123; public static void main(String[] args) throws IOException &#123; ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(&quot;provider.xml&quot;); classPathXmlApplicationContext.start();//实例化类，将实例化后的类放入容器中。 System.out.println(&quot;服务发布成功！！！&quot;); System.in.read(); &#125;&#125; 搭建dubbo_consumer消费端调用类1234567891011121314151617181920package com.jihongyun.consumer.controller;import com.jihongyun.po.User;import com.jihongyun.service.IUserService;import jdk.nashorn.internal.ir.ReturnNode;import org.springframework.stereotype.Controller;import javax.annotation.Resource;/** * Created by xlf on 2018/11/6. */@Controllerpublic class UserController &#123; @Resource private IUserService userService; public User queryUserByUserId(Integer userId)&#123; return userService.queryUserById(userId); &#125;&#125; consumer.xml配置12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.jihongyun.consumer.controller&quot;/&gt; &lt;!--dubbo环境配置--&gt; &lt;dubbo:application name=&quot;dubbo_consumer&quot;/&gt; &lt;!--指定注册中心--&gt; &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;/&gt; &lt;!--配置订阅服务--&gt; &lt;dubbo:reference id=&quot;userService&quot; interface=&quot;com.jihongyun.service.IUserService&quot;/&gt;&lt;/beans&gt; 消费端测试类123456789101112131415package com.jihongyun.consumer;import com.jihongyun.consumer.controller.UserController;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created by xlf on 2018/11/6. */public class TestConsumer &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(&quot;consumer.xml&quot;); UserController userController = (UserController) classPathXmlApplicationContext.getBean(&quot;userController&quot;); System.out.println(userController.queryUserByUserId(1)); &#125;&#125;","categories":[{"name":"Apache Dubbo","slug":"Apache-Dubbo","permalink":"http://yoursite.com/categories/Apache-Dubbo/"}],"tags":[]},{"title":"阿里云服务系统：centOS7部署MySQL","slug":"MySQL的部署","date":"2018-11-05T08:16:32.530Z","updated":"2018-11-06T14:55:17.262Z","comments":true,"path":"2018/11/05/MySQL的部署/","link":"","permalink":"http://yoursite.com/2018/11/05/MySQL的部署/","excerpt":"","text":"阿里云服务系统：centOS7部署MySQL一、使用root登陆服务器为了避免不必要的踩坑，直接先更新一下系统。1执行命令：yum -y update 等待出现：123 grub2.x86_64 1:2.02-0.64.el7.centos grub2-tools.x86_64 1:2.02-0.64.el7.centosComplete! 二、重启服务器1执行命令：init 6 三、先检查一下自己是否装了MySQL数据库，如果已经装了将其删除，避免后续不必要的麻烦。1检查命令： rpm -qa | grep mysql 1卸载命令： yum –y remove mysql 四、下载MySQL安装包执行命令：（两个不同的版本自行选择）1rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 1rpm -ivh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm 等待下载 五、安装MySQL1执行命令：yum install -y mysql-server 等待出现Complete！ 六、开启服务执行命令：systemctl start mysqld.service 七、查看MySQL默认的密码1执行命令：grep &apos;temporary password&apos; /var/log/mysqld.log 第一次装，应该是没有的（我的是没有的）。 八、登录MySQL1.上一步没有获取到密码。1执行命令：mysql -uroot -p 如果输入密码直接回车。 2.上一步获取到密码。例如密码为：password1执行命令：mysql -uroot -ppassword 九、进入MySQL系统，修改掉当前用户的密码。例如：修改密码为”Abc123!_“。1执行命令：SET PASSWORD = PASSWORD(&apos;Abc123!_&apos;); 搞了这么多不就是想远程登录。激动人心的时候到了。 十、开启远程登录，授权root远程登录。1执行命令：GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;Abc123!_&apos; WITH GRANT OPTION; 为了将授权立即生效：1执行命令：flush privileges; 好了centOS7上面的MySQL已经部署好了，下一步我们就通过Navicat连接。","categories":[{"name":"项目的简单部署","slug":"项目的简单部署","permalink":"http://yoursite.com/categories/项目的简单部署/"}],"tags":[]}]}